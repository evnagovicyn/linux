выделить левой кнопкой - затем щелкнуть средней - копировать/вставить фрагмент текста
фокус передается по щелчку - не по движению мыши

CTRL+SHIFT+C		copy
CTRL+SHIFT+V		paste

приглашение к вводу (shell prompt) - [username@computername workingdir]
~			домашний каталог пользователя
если последний символ в приглашении - #, то сеанс в оболочке имеет права рута (суперпользователя)

стрелки вверх/вниз	листать историю команд
стрелки влево/вправо	управлять позицией курсора

date 			текущая дата и время
cal 			календарь
df 			disk free, объем свободного пространства на дисках
 -h			human readable
 -T			тип
 -i			айноды
du			disk usage, сколько занято места
 -h			human readable
 -s			суммарный объем для каждого аргумента
free 			объем свободной оперативной памяти
uname			версия ядра

ctrl-alt-f*		переключение между терминалами

pwd 			print working directory - текущий каталог
cd 			change directory - смена каталога
ls 			список каталогов и файлов
realpath		реальный и наиболее правильный путь к файлу
ll			 ls -la

максимальная длина имени файла - 255 символов
/ - корневой каталог, все остальные каталоги находятся в нем.
по сути файловая система - перевернутое дерево с корнем вверху, от которого расходятся различные каталоги
абсолютный путь - путь, начинающийся с корня, например /home/nag
относительный путь - путь относительно текущей директории, например в директории /home/nag путь Downloads - относительный
.	текущий каталог
..	родительский каталог
файлы и каталоги, начинающиеся с . считаются скрытыми, и ls выведет их только с ключом -a
расширения файлов не имеют значения для ОС, но могут иметь значение для софта
кроме букв и цифр, в названии каталогов и файлов следует использовать только тире и подчеркивание

cd - 			предыдущий рабочий каталог
cd ~ 			домашний каталог текущего пользователя
cd ~username 		домашний каталог пользователя username

ls можно использовать с названием директории или файла (и нескольких) - выведет содержимое директории или информацию о файле
несколько параметров можно комбинировать в одну строку
ls:
 -a			выводить все файлы и каталоги
 -А			выводить все файлы, кроме . и ..
 -l			подробный вывод
 -t			сортировать по времени последнего изменения
 -S			сортировать по размеру
 -r			в обратном порядке
 -d			инфо о самом каталоге, а не его содержимом
 -h			отображает размер в понятных единицах измерения
 -i			вывести айноды
вывод ls:
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Desktop
1 столбец 		тип файла и права (юзер, группа, остальные)
2 			количество хардлинков
3 			владелец
4 			группа владелец
5 			размер (1 блок 4096 байт в ext4)
6 			дата и время последнего изменения
7 			имя файла

stat			информация из айнод
file 			тип файла
reset			сброс оболочки
clear			очистка окна терминала
history			содержимое истории команд

less			просмотр текстовых файлов (пейджер)
 PgUp/b			на одну страницу назад
 PgDn/Space		на одну страницу вперед
 Up/Down		на одну страницу назад/вперед
 G/g			в конец/начало файла
 /string		искать ниже по тексту строку
 n/N			следующая/предыдущая строка по поиску
 h			справка
 q			выйти

интересные каталоги:
/bin			бинарники, скрипты для баша
/boot			ядро, загрузчик
/dev			устройства
/etc			конфиги
/home			домашние папки юзеров
/lib			библиотеки
/lost+found		частично восстановленные файлы
/media			каталог для монтирования флэшэк, дисков
/mnt			то же самое
/opt			дополнительное по сторонних разработчиков
/proc			вфс, отображает процессы в системе
/root			папка рута
/sys			информация об устройствах, драйверах, ядре
/tmp			временные файлы
/var/log		логи

символические ссылки (симлинки):
занимают новую айноду, по сути новый блок данных, который просто ведет на другой уже существующий.
если удалить саму ссылку, то файл останется на месте, если удалить файл - образуется битая ссылка.
по сути это ярлыки из винды.
жесткие ссылки (хардлинки):
занимают ту же айноду, что и цель, по сути новое имя для того же блока данных.
неотличимы от файлов. Пока есть хотя бы 1 хл, файл существует.
Как только последний хл удален - файл удален.
хардлинки можно создавать только в рамках одной ФС
нельзя создавать хардлинки на директории
ln -s цель название	создать симлинк
ln цель название	создать хардлинк
!цель должна иметь путь относительно директории, в которой будет сама ссылка, либо абсолютный путь!

cp			копирование, если без -r, то целевой каталог должен существовать
cp -a			скопировать со всеми атрибутами (права, владельцы) - по умолчанию берутся атрибуты по умолчанию для юзера, выполняющего копирование
cp -u			скопировать только новые файлы (раннее не существующие или с более поздней датой изменения)
cp -r			рекурсивное копирование (копирование файлов). Если каталог существует - скопирует сам каталог и содержимое,
			если не существует - создаст и заполнит содержимым
cp -i			спрашивать подтверждение перед перезаписью (по умолчанию перезаписывает без подтверждения)
cp -v			выводить подробные сообщения
mv			перемещение/переименование (если целевой каталог не существует - создаст его и в нем уже сразу будут внутренности исходного каталога, 
			если существует - переместит в него)/ если при перемещении файлов целевой файл уже существует - перезапишет его без подтверждения
mv -u			тот же смысл, что с cp
mv -v			то же, что с cp
mv -i			то же, что с cp
rm			удаление
rm -r			рекурсивное удаление (удаление каталогов)
rm -i			то же, что и для cp и mv
rm -f			игнорировать отсутствующие файлы и не запрашивать подтверждения
rm -v			то же, что и для cp и mv
rmdir			удаление каталогов (пустых)
mkdir			создание каталога
 -p			создание каталога с подкаталогами
touch			создание пустого файла или обновление времени изменения существующего

wildcards:
*			любое количество любых символов
?			один любой символ
[abc]			любой один символ из abc
[!abc]			любой один символ не из !abc
[[:класс:]]		любой один символ из указанного класса
[a-d]			любой символ из диапазона символов

!перед тем, как проводить операции с файлами с использованием подстановок,
лучше проверить, какие файлы попадут под операцию, используя ls с теми же подстановками!
!!оболочка раскрывает джокеры ПЕРЕД выполнением команд. Если надо передать джокер
команде, то следует заключить его в одиночные кавычки!!

классы:
[:alnum:]		любой алфавитно-цифровой символ
[:alpha:]		любой алфавитный символ
[:digit:]		любой цифровой символ
[:lower:]		любая буква в нижнем регистре
[:upper:]		любая буква в верхнем регистре

xdg-open		открыть файл в назначенной для данного типа файлов программе
xclip -sel clip -i file	скопировать файл в буфер
xclip -sel clip -o	вставить из буфера

type			тип команды (встроенная, бинарник, альяс)
whereis			путь к бинарнику и ману
which			местоположение исполняемого файла
whatis			путь к бинарнику и краткое описание
who			кто работает в системе
whoami			аналогично
help			справка по команде
--help			ещё одна справка
man			страницы руководства по команде

разделы man:
1			пользовательские программы
2			интерфейсы системных вызовов в ядре
3			интерфейсы в библиотеке си
4			специальные файлы(устройства, драйвера)
5			форматы файлов
6			игры и развлечения
7			прочее
8			команды системного администрирования
использование разделов:
man раздел искомая_информация

apropos			найти страницы руководство для близких совпадений с искомым термином
man -k			то же, что и apropos
man bash		самая экстремальная "страница" руководства

whatis			имя и краткое описание программы
info			ещё одна справка
 ?			вывести справка
 PgUp/Backspace		предыдущая страница
 PgDn/Space		следующая страница
 n			следующий раздел
 p			предыдущий раздел
 u			вывести родительский раздел по отношению к текущему
 enter			перейти по ссылке, находящейся под курсором
 q			выход

zless			выводит содержимое файлов, сжатых архиватором gzip

команды можно разделить ; и поместить в одну строку
alias name='command[s]'	создать альяс
unalias			удалить альяс
alias без аргументов	список альясов

3 стандартных потока:
дескриптор 0		стандартный ввод
дескриптор 1		стандартный вывод
дескриптор 2		стандартная ошибка

перенаправление вывода:
>			перенаправить вывод. Если в файл, то если файл существует, он будет перезаписан (всегда), если не существует - создан
>>			тоже, но если файл существует, вывод будет дописан, то есть для очистки файла можно просто написать
			> file	очистит файл
2>			перенаправление дескриптора 2 (поток ошибок)
2>&1			перенаправление потока ошибок туда же, куда и дескриптор 1 (поток вывода)
аргументы перенаправления читаются слева направо, так что порядок перенаправления важен:
..>file 2>&1		перенаправит поток ошибок в file
  2>&1 >file		перенаправит поток ошибок на экран, а поток вывода в файл
в современных bash:
&>			перенаправление сразу и вывода и ошибок

/dev/null		спец файл, битоприемник, который ничего не делает с вводом. Перенаправление сюда отбросит выбранный поток

<			перенаправление дескриптора 0 (потока ввода). Позволяет использовать файлы в качестве источника данных для команды
|			отправить вывод одной команды на ввод другой - создать конвеер (pipeline, pipe)

cat			чтение одного или нескольких файлов в стандартный вывод
без аргументов		чтение стандартного ввода с консоли. Ctrl+D, чтобы закончить.

cat > file		создать файл и заполнить его потоком из стандартного ввода

sort			сортировка ввода
uniq			поиск и удаление повторяющихся строк из ввода
 -d			не удаляет, а наоборот оставляет только дублирующиеся строки
wc			вывод числа байт, слов и строк
 -l			только число строк
grep			супер мощная фильтрация по регуляркам
 -i			игнорировать регистр
 -R			рекурсивный поиск
 -l			имена файлов
 -v			только строки, где совпадение НЕ найдено
    [ ]			диапазон
    ^			отрицание
    +			1 и более раз
    |			или
    \s			пробельные символы
    *			0 и более раз
    ?			может быть а может и не быть
    { }			количество символов
head			вывести первые 10 строк
 -n 5			не 10, а 5 строк
tail			вывести последние 10 строк
 -n 5			не 10, а 5
 -f			мониторинг за изменением файла (супер вещь)
tee			выводить информацию со стандартного ввода в файл И в стандартный вывод
echo			выводит стандартный ввод на стандартный вывод

.[!.]?*			шаблон для вывода файлов с точкой, но без директорий . и ..
.??*			аналогично
~			домашний каталог текущего пользователя
~user			домашний каталог пользователя user
$((выражение))		можно считать арифметические выражения
 +			сложение
 -			вычитание
 *			умножение
 /			деление
 %			остаток от деления
 **			возведение в степень
{1,2,3}			вывести множество строк с каждым из аргументов
{001..15}		то же самое, с использованием диапазона
echo $VAR		вывести переменную VAR
$USER			имя пользователя
$PATH			командный путь


printenv		список доступных переменных
$(cmd)/'cmd'		подстановка вывода команд в качестве аргументов других команд (не тоже самое, что перенаправление)
например ls -l $(which cp) выведет информацию о файле /bin/cp
""			двойные кавычки позволяют экранировать некоторые специальные символы, и интерпретировать их как обычные
при этом подстановка параметров, арифметики и команд все ещё работают в двойных кавычках.
''			одинарные кавычки позволяют экранировать вообще все специальные символы
\			экранировать 1 символ или ввести управляющий символ
 \a			звонок
 \b			backspace
 \n			новая строка
 \r			возврат каретки
 \t			табуляция
\\			экранировать обратный слэш
echo -e			позволяет интерпретировать управляющие символы
$''			тоже самое

CTRL+A			в начало строки
CTRL+E			в конец строки
CTRL+F			на один символ вперед (стрелка вправо)
CTRL+B			на один символ назад (стрелка влево)
ALT+F/CTRL+вправо	на одно слово вперед
ALT+B/CTRL+влево	на одно слово назад
CTRL+L			очищает экран (clear)
CTRL+D			удаление символа под курсором
CTRL+T			поменять местами 2 символа - под курсором и предыдущий
ALT+T			поменять местами 2 слова - под курсором и предыдущий
ALT+L			перевести в нижний регистр символы, начиная с позиции под курсором и до конца слова
ALT+U			перевести в верхний регистр символы, начиная с позиции под курсором и до конца слова
CTRL+K			удалить символы от позиции курсора до конца строки
CTRL+U			удалить символы от позиции курсора до начала строки
ALT+D			удалить символы от позиции курсора до конца слова
ALT+BACKSPACE		удалить символы от позиции курсора до начала слова
CTRl+Y			извлекает текст из буфера удалений и вставляет его в позицию курсора
TAB			дополнение, работает с:
    именами переменных в $
    именами пользователей в ~
    командами
    файлами
    сетевыми именами

!число			подстановка записи из истории под данным номером строки
CTRL+R			поиск по истории
ENTER			выполнить найденную в истории команду
CTRL+J			закончить поиск по истории и скопировать найденную команду
CTRL+G/C		закончить поиск по истории

script [file]		сохранение в файл сеанса работы с командной строкой, либо в файл typescript по умолчанию

id			выводит информацию о юзере
chmod			изменение прав
umask			разрешения доступа к файлам по умолчанию
su			запуск оболочки от имени другого пользователя
sudo			запуск команды от имени другого пользователя
chown			смена владельца файла
chgrp			смена группы файла
passwd			смена пароля пользователя
addgroup		добавление группы
useradd			добавление пользователя
 -g			в конкретную группу
chsh			сменить оболочку
groups			посмотреть, в какие группы входит пользователь

CTRL+D			выйти из сеанса (команда exit)

/etc/passwd		учетные записи
/etc/group		группы
/etc/shadow		хэши паролей
vipw			команда для редактирования /etc/passwd
/etc/sudoers		права привилегированных пользователей
visudo			команда для редактирования /etc/sudoers

максимальная длина имени юзера - 32 символа, нельзя использовать : и new line
root uid = 0

uid			user id
gid			group id

типы файлов:
 -			обычный файл
 d			каталог
 l			симлинк
 c			символьное устройство (обрабатывают данные как потоки байтов)
 b			блочное устройство (обрабатывают данные блоками - диски)
 p			канал (пайп) - на другом конце располагается процесс (именованные каналы)
 s			сокет - также для взаимодействия процессов

права:
группа из 3 бит для каждой категории
u - user
g - group
o - other
---------
a - all, все
r - открытие и чтение файла. чтение содержимого каталога (ограниченно, если нет прав x)
w - запись в файл или удаление информации из него, но не переименование или удаление самого файла. переименование или перемещние каталога, создание, удаление и переименование файлов внутри каталога (если стоит x)
x - запуск бинарников/интерпретация скриптов. вход в каталог

изменить права может только владелец или рут.
chmod удобно использовать с восьмеричными цифрами, т.к. каждая группа содержит по 3 бита, определяющих права доступа.
0	000	---
1	001	--x
2	010	-w-
3	011	-wx
4	100	r--
5	101	r-x
6	110	rw-
7	111	rwx
chmod 777	7 для user, 7 для group, 7 для other
chmod (u/g/o/a)(+/-/=)(r/w/x) - смена прав в символьном режиме, через запятую можно указывать разные режимы для разных групп

umask	выводит или задает маску, которая применяется к файлам по мере их создания

скрытые биты:
setuid	при применении к исполняемому файлу, при его запуске он запускается от имени владельца, а не запускающего юзера
setgid	то же, только для группы. для каталога - создаваемые файлы будут группе-владельцу, а не группе юзера, создавшего файл
sticky	для каталогов не позволяет удалять или переименовывать файлы

su username		запуск нового сеанса оболочки от имени username
 -l			запущенная оболочка станет оболочкой входа, т.е. будет загружено окружение пользователя и текущим каталогом станет его домашний каталог
 -c			выполнить команду
если пользователь не указан, подразумевается root
-l можно сократить до -
su -			запустить оболочку от имени рута

sudo			запустить команду от имени рута, используя свой пароль
 -l			список привилегий
 -i			интерактивный режим

sudo su			работать под рутом

chown user:group file	изменить владельца и группу-владельца файла
можно менять отдельно владельца и отдельно группу:
chown user		назначить владельца
chown :group		назначить группу-владельца
chown user:		назначить владельца и его группу

chgrp			тоже позволяет сменить группу-владельца
usermod			модификация пользователя

pid			process id
ppid			parent process id

ps			список процессов для текущего терминала
 x			для всех терминалов
 -A/-e			для всех пользователей
 -u			user-oriented format
 -f/F			подробный/очень подробный формат
 -l			ещё один подробный формат

состояния (stat):
 R			выполняется
 S			приостановлен
 D			приостановлен без возможности прерывания
 T			остановлен
 Z			зомби (процесс, который завершился, но результат работы не был обработан родителем)
 <			высокоприоритетный процесс
 N			низкоприоритетный процесс

daemon			программа, работающая в фоне без прямого взаимодействия
зомби			состояние процесса между своим exit() и wait() родителя
сирота			процесс без родителя
чтобы убить зомби, надо сделать его сиротой, тогда его усыновит initd, считает код возврата и завершит
& в конце команды - запустить в фоне, выводит номер задания и пид
CTRL+C			завершить команду
CTRL+Z			приостановить команду

top			мониторинг процессов в реальном времени
1 строка:
    имя программы
    текущее время
    аптайм
    количество юзеров
    среднее число ожидающих ресурсов процессов за 60 секунд, 5 минут и 15 минут, дб <= кол-во ядер
	в linux в эту очередь попадают процессы, ожидающие ввода-вывода
2 строка:
    сколько процессов и их статус
3 строка:
    us	потрачено п.времени в пространства пользователя
    sy	в пространстве ядра
    ni	потрачено п.времени на процессы с пониженным приоритетом
    id	простой
    wa	потрачено на ожидание ввода-вывода
    hi	потрачено на аппаратные прерывания
    si	потрачено на системные вызовы
    st	загрузка хостовой машины для виртуалок
4 строка использование озу
5 строка использование файла подкачки
S			поменять время обновления
1			показать по ядрам

jobs			показать список заданий
fg			вернуть задание в передний фон
fg %1			вернуть задание № 1
bg			перевести в фоновый режим приостановленную команду
kill			завершить процесс
 -l			список сигналов
сигналы:
1	HUP		обрыв связи, пережиток прошлого
2	INT		прервать (CTRL+C)
3	QUIT		выйти?
9	KILL		безусловное завершение (необрабатываемый сигнал. Только init может его обработать)
11	SEGV		ошибка сегментации - посылается программе, которая пытается допустить неправильный доступ к памяти
15	TERM		завершение, сигнал по умолчанию. Можно обработать и прибрать за собой
18	CONT		продолжить, восстановление после STOP
19	STOP		приостановить. Как и KILL не обрабатывается, просто приостанавливает
20	TSTP		приостановить (CTRL+Z), обрабатываемый сигнал
28	WINCH		изменение размера окна (влияет, например, на less и top)
kill сигнал пид		передать указанный сигнал указанному процессу

killall			позволяет послать сигнал программам, соответствующим определенному пользователю или имени программы

halt			приостановить функции CPU, но оставить включенным
poweroff		выключить питание
reboot			перезагрузка
shutdown		выключение системы
 now			сейчас

pstree			дерево процессов
vmstat			снимок об использовании системных ресурсов
tload			график загрузки системы в реальном времени


set			выводит список и переменных окружения и переменных оболочки

файлы запуска для сеансов командной оболочки:
/etc/profile		общесистемный конфиг для всех пользователей
~/.bash_profile		пользовательский файл запуска для переопределения системных настроек
~/.bash_login		вместо bash_profile
~/.profile		вместо bash_profile и bash_login

файлы запуска для сеансов оболочки из графического окружения:
/etc/bash.bashrc	общесистемный конфиг
~/.bashrc		пользовательский конфиг для переопределения или добавления настроек

export $VAR		сделать доступной переменную окружения для дочерних процессов (т.е. для fork())
экспортировать переменные следует в .bashrc

nano
    CTRL+X		выйти
    CTRL+O		сохранить

source конфигc		заставить шелл повторно прочитать конфиг
. конфиг		аналогично

vim
    :q!			выйти
    i			режим вставки (курсор остается на месте вставки)
    :w			запись изменений
    :wq!		сохранить и выйти
    l/вправо		вправо на 1 символ
    h/влево		влево на 1 символ
    j/вниз		вниз на 1 строку
    J			объединить текущую строку со следующей
    k/вверх		вверх на 1 строку
    0			в начало строки
    ^			к первому непробельному символу в строке
    $			в конец строки
    w			в начало следующего слова или к знаку препинания
    W			в начало следующего слова минуя знаки препинания
    b			в начало предыдущего слова или к знаку препинания
    B			в начало предыдущего слова минуя знаки препинания
    CTRL+F/PgDn		вниз на одну страницу
    CTRL+B/PgUp		вверх на одну страницу
    nG			к строке n
    G			к последней строке
    u			отмена последнего действия
    a			режим добавления (курсор уходит за выделенный символ)
    A			перейти в конец строки и включить режим добавления
    o			вставить строку ниже текущей
    O			вставить строку выше текущей
    x			удалить символ в позиции курсора
    3х			текущий символ и следующие 2
    dd			удалить текущую строку
    5dd			текущую строку и следующие 4
    dW			от символа в позиции до начала следующего слова
    d$			до конца строки
    d0			до начала строки
    d^			до первого непробельного символа
    dG			до конца файла от текущей строки
    d20G		от текущей строки до 20 строки файла
    p			вставка справа от курсора
    P			вставка слева от курсора
    yy			скопировать текущую строку
    5yy			скопировать текущую строку и следующие 4
    yW			от курсора до начала слова
    y$			до конца строки
    y0			до начала строки
    y^			до первого непробельного символа
    yG			до конца файла от текущей строки
    y20G		от текущей строки до 20 строки файла
    f			поиск в строке, ; - повторить поиск
    /			поиск по файлу, n - следующий результат, N - предыдущий. Можно регулярками
    :%s/что/на что/g	замена первого на второго, с поиском по всему файлу (%) и глобальной заменой (g)
	c		запрашивать подтвеждение на замену
	    y		заменить
	    n		пропустить
	    a		заменить это и все последующие
	    q		завершить
	    l		заменить и завершить
	    CTRL+E/CTRL+Y	прокрутить вверх/вниз
    :bn			следующий файл
    :bp			предыдущий файл
    :buffers		список редактируемых файлов
    :buffer n		перейти к файлу n
    :e file		открыть доп файл для редактирования
    :r file		вставить файл перед курсором
    ZZ			в командном режиме сохранить и выйти

PS1			строка приглашения


.deb			пакеты в Debian based
.rpm			пакеты в Red Hat based

dpkg			низкоуровневый инструмент
apt*			высокоуровневый инструмент

apt-get update		обновить кэш
apt-cache search	поиск пакета
apt-get install		установка пакета из репо
dpkg -i			установка/обновление пакета из файла(возможно нужно будет разрешить зависимости)
apt-get remove		удаление пакета
apt-get upgrade		обновление установленных пакетов
dpkg -l			список установленных пакетов
dpkg -s			установлен ли определенный пакет
apt-cache show		получить описание пакета
dpkg -S			в составе какого пакета был установлен тот или иной файл


/etc/fstab		устройства (обычно разделы дисков), монтируемые на этапе загрузки
/etc/mtab		смонтированные фс

mount			список смонтированных файловых систем
parted -l		список подключенных дисков
fdisk -l		тоже самое
fdisk ус-во		низкоуровневая работа с диском
    p			показать таблицу разделов
    l			список допустимых типов разделов
    t			изменить тип раздела
    w			записать изменения
    q			покинуть программу без записи изменений
lsblk			информация о блочных устройствах
lsblk -o UUID		посмотреть уиды
umount папка/уст-во	размонтировать
mount уст-во папка	смонтировать
    -t			указать тип фс (iso9660, ntfs, ..)
mkfs -t тип ус-во	создать фс на устройстве
fsck			проверка фс
dd -if=in of=out	низкоуровневое копирование блоков байтов напрямую
    -if=ус-во		источник данных
    -of=ус-во		приемник данных
dd -if=/dev/sdrom -of=.iso	создать образ диска
dd -if=/dev/null -of=ус-во	затереть нулями
genisoimage -o .iso -R -J /path	создать образ iso из содержимого path
mount -o loop -t iso9660	смонтировать образ iso как устройство
wodim dev=ус-во blank=fast	очистка перезаписываемых дисков
wodim dev=ус-во .iso		записать образ на диск
md5sum .iso		проверить контрольную сумму образа

sda			физический диск
sda1			логический диск

/dev/fd*		приводы гибких дисков
/dev/hd*		приводы ide
/dev/lp*		принтеры
/dev/sd*		диски scsi
/dev/sr*		приводы

/var/log/messages	можно замониторить этот лог для определения имени устройства при подключении (tail -f)

для устройств ls -l вместо размера выведет старший и младший номер устройства

ping			проверка связи (не всегда проходит, можно отключить)
traceroute/tracepath	список хопов на пути сетевого трафика
    -T/-I		? преодолеть ограничение по блокировке информации маршрутизаторами
ip a			список интерфейсов
netstat -ie		ещё инфа об интерфейсах
netstat -r		таблица маршрутизации ядра
ftp server		подключиться к серверу по ftp:// порт 21
    lcd			переход в директорию в локальном окружении
    get			апрос на получение файла
    bye/exit		выход
lftp			продвинутая альтернатива ftp
sftp			ftp через ssh (sftp://)
wget			для загрузки файлов
wget http://some.com/file.deb		http
wget ftp://login:password@host/path	ftp
    -r			рекурсивно
    -l			ограничить уровень (0 - без ограничений)
scp			скачать по ssh
scp -r user@host:/path
ssh			secure shell порт 22
ssh user@host		подключиться
ssh-keygen -t rsa -b 4096 -C "email"	генерация ссш-ключей
ssh -X/-Y		запустить с графическим интерфейсом
putty			программа для винды для доступа по ssh

locate			быстрый поиск в индексе по именам файлов
updatedb		обновление индекса
find dir		список содержимого каталога
find dir -type d	только каталоги
    -type b		блочное устройство
    -type c		символьное устройство
    -type f		обычный файл
    -type l		символьная ссылка
find -name ""		поиск по имени
find -size +1M		поиск по размеру (более 1 Мб, минус - менее 1 Мб, без знака - ровно 1 Мб)
    -cmin n		файлы, которые изменялись n минут назад
    -cnewer имя		изменялись позже, чем указанный файл
    -ctime n		изменялись более чем n*24 часов назад
    -empty		пустые
    -group		принадлежащие указанной группе
    -iname		то же, что и name, но с учетом регистра
    -inum		поиск по айноде
    -mmin n		то же что и cmin, только не учитывает изменение атрибутов
    -mtime n		то же, что и ctime, только не учитывает изменение атрибутов
    -newer имя		то же, что и cnewer, только не учитывает изменение атрибутов
    -nouser		файлы, не принадлежащие какому-либо допустимому пользователю
    -nogroup		не принадлежащие какой-либо допустимой группе
    -perm		файлы с указанным режимом доступа
    -samefile имя	поиск файлов с такой же айнодой, как у указанного (поиск хардлинков)
    -user		принадлежащие пользователю с указанным именем
    -and		должны выполняться оба условия (по умолчанию)
    -or			должно выполняться одно из условий
    -not		следующее условие не должно выполняться
    ()			изменение порядка проверок (нужно экранировать)
логические операторы работают лениво - если второй операнд нет смысла проверять, он не будет проверен
    -delete		удалить найденное
    -ls			ls -dils для найденного
    -print		по умолчанию - выводит полный путь к найденному
    -quit		завершает поиск после первого совпадения
    -exec cmd {} ;	выполнить команду для найденного, {} - представление текущего пути, ; - разделитель (надо экранировать)
    -ok вместо exec	спрашивать перед выполнением
    изменить ; на + - выполнит указанную команду 1 раз для всех результатов (т.е. несколько аргументов)

xargs			принимает входные данные со стандартного ввода и преобразует их в список аргументов команды

gzip			сжать // .gz
    -c			вывести результат на стандартный вывод и сохранить оригинал
    -d			распаковать файл (тот же gunzip)
    -f			принудительное сжатие, даже если сжатый файл уже существует
    -h			порядок использования
    -l			список статистик для каждого сжатого файла
    -r			рекурсивное сжатие данные внутри каталогов
    -t			проверка целостности сжатого файла
    -v			выводит подробный вывод в процессе сжатия
    -число		от 1 до 9 (степень сжатия от низкой до высокой)
gunzip -c file.gz | less = zless
gunzip -dc file.gz 	 = zcat

bzip2			другое сжатие (сильнее, но медленнее) // .bz2
bunzip2, bzcat		распаковка
bzip2recover		осстановление битых архивов

tar			архиватор, режимы (всегда указываются первыми):
    с			создать архив из списка файлов или каталогов
    x			извлечь файлы из архива
    r			добавить указанный файл или каталог в конец архива
    t			вывести список содержимого архива
    параметры:
    f			имя файла
    v			verbose
    vv			mega verbose )
    z			gzip сжатие
    j			bzip2 сжатие
    p			сохранить исходные права доступа и проигнорировать umask
можно указать конкретный файл для извлечения
    --wildcards		указать конкретный файл с использованием подстановок
    -T/--files-from	читать список путей из файла
используя - указываем стандартный ввод в качестве источника 
или стандартный вывод в качестве приемника вместо файла

соответственно .tar.gz/.tgz	сжатый архив

zip			для сжатия и разжатия архивов для винды
    -r			рекурсивно добавить содержимое каталогов
unzip			понятно
    -l			вывести содержимое
    -v			verbose

xz			ещё одна команда для сжатия, может сжать лучше чем bzip2

rsync args source dest	синхронизация каталогов
    source/dest:
	локальный файл или каталог
	удаленный файл или каталог в форме [user@]host:path
	удаленный сервер rsync определяемый по URI: rsync://[user@]host[:port]/path
	либо источник, либо приемник должны находиться в локальной системе
	если источник заканчивается /, то будет скопировано только содержимое без создания ещё одного уровня
    -a			рекурсивный обход и сохранение атрибутов файлов
    -v			verbose
    --delete		удалить файлы с приемника, которых нет в источнике
    -rsh=ssh		использовать в качестве удаленного шелла ссш

grep			global regular expression print
    -i			игнорировать регистр
    -v			инвертировать результат - выводить то, что не совпадает
    -c			вывести число совпадений
    -l			вывести имена файлов с совпадениями
    -L			вывести имена файлов без совпадений
    -n			выводить номер строки с совпадением
    -h			не выводить имена файлов при поиске по нескольким файлам

регулярки: передавая регулярку, следует заключить её в кавычки, чтобы шэлл не пытался интерпретировать специальные символы
    .			любой символ
    ^			в начале строки
    $			в конце строки
    []			множество символов (один из символов)
	^		имеет смысл отрицания в множестве, но только в начале множества
	-		обозначить диапазон, но в начале множества - обозначает просто символ
	[A-Z], [a-z], [0-9],[A-Za-z0-9]

egrep/grep -E		с поддержкой расширенных регулярных выражений
    |			или
    ?			совпадение 0 или 1 раз
    *			совпадение 0 или более раз
    +			совпадение 1 или более раз
    {n]			совпадение n раз
    {n,m}		совпадение от n до m раз
    {n,}		не менее n раз
    {,m}		не более m раз

find -regex		поиск с использованием регулярок
locate -regexp		поиск с простыми регулярками
locate -regex		поиск с расширенными регулярками
поиск в less и vim по регуляркам - /регулярка

расширенная обработка текста
cat -A			показать непечатаемые символы в тексте
cat > file		будет получать со стандартного ввода и писать в файл
cat file1 file2		склеить несколько файлов
unix2dos/dos2unix	преобразовать концы строк в нужный формат
cat -n			вывод номеров строк
cat -s			подавить вывод подряд идущих пустых строк
sort > file		по аналогии с cat
sort file1 file2	отсортировать несколько файлов
sort -b			начинать сортировку с первых непробельных символов в строке
    -f			без учета регистра
    -n			сортировка в соответствии с числовыми значениями
    -r			в обратном порядке
    -k			сортировка по ключевым полям
    -m			интерпретировать каждый аргумент как предварительно отсортированный файл
    -o			записать вывод в файл
    -t			определить символ разделитель полей
uniq			удаляет повторяющиеся строки из сортированного файла
sort -u			аналогично
uniq -c			вывести список повторяющихся строк и их количество
    -d			вывести только повторяющиеся строки
    -f n		пропустить n полей в каждой строке (поля разделяются пробельными символами)
    -i			равнивать без учета регистра
    -s n		пропустить n символов в каждой строке
cut			извлечение фрагментов из строк
    -c список		извлекает фрагмент строки, определяемый списком символов
    -f список		извлекает фрагмент строки, определяемый списком полей
    -d символ		устанавливает символ-разделитель полей
cut -A			отвечает ли файл требованию по использованию символа табуляции в качестве разделителя
expand			замещает табуляцию пробелами
unexpand		наоборот
paste			добавляет 1 или более колонок в файл
join			объединение строк из файлов по общему полю
comm			построчное сравнение сортированных файлов
    -n			число 1,2 или 3 (или комбинация) - какие колонки выводить
diff			сравнение файлов
    -c			контекстный режим
    индикаторы:
    нет			отсутствую различия
    -			строка удалена
    +			строка добавлена
    |			строка изменена
    -u			унифицированный формат (ещё более приятный чем контекстный)
patch			применение изменений к файлам от программы diff
diff -Naur old new > patch	сгенерировать патч
patch < patch file	применить патч
tr			перекодирование символов
    -d			удалить, а не заменить символы
    -s			удаляет повторяющиеся символы
split			разбивает файлы на фрагменты

sed			stream editor, потоковый редактор текста. Супер мощная тулза, достойная отдельной книги
awk			ещё один мощный инструмент, основное достоинство которого это работа с табличными данными
perl			используется вместо скриптов оболочки для решения задач администрирования

aspell check file	проверить орфографию в файле

nl			проставляет нумерацию строк
    -b			стиль нумерации тела
	a		нумеровать все строки
	t		нумеровать только непустые строки (по умолчанию)
	n		не нумеровать
	regex		нумеровать строки, соответствующие простой регулярке
fold -w n		разрыв строк по длине n
    -s			по последнему доступному пробелу
fmt			перенос строк и формирование абзаца
    -w n		поместить в колонку шириной n символов
    -c			сохраняется отступ первой строки, а последующие строки выравниваются по второй строке
pr			подготовка к печати
    -l			длина страницы
    -w			ширина страницы
    +первая[:посл]	вывести диапазон страниц с 1 по последнюю
    -колонок		вывести содержимое в указанное количество колонок
    -a			для нескольких колонок - организовать колонки по горизонтали, а не по вертикали
    -d			вывести с двойным интервалом
    -D формат		формат вывода даты в строке заголовка страницы
    -f			использовать символ перевода формата вместо возврата каретки для разделения страниц
    -h			текст для вывода в центре заголовка вместо имени файла
    -n			нумеровать строки
    -o			отступ левого поля первой строки в символах
    -t			опустить верхние и нижние колонтитулы

ps2pdf			преобразование ps файлов (post script) в pdf (portable document format)
a2ps			ascii/anything to postscript, по умолчанию выводит на принтер
    --center-title 	текст для заголовка в центре
    --columns n		число колонок
    --footer text	текст нижнего колонтитула
    --guess		вывести типы файлов, переданных в аргументах
    --left-footer	текст нижнего колонтитула слева
    --left-title	текст заголовка страницы слева
    --line-numbers=n	вывод номеров строк через заданный интервал
    --list=defaults	вывести настройки по умолчанию
    --pages диапазон	вывести страницы из указанного диапазона
    --right-footer	текст нижнего колонтитула справа
    --right-title	текст заголовка страницы справа
    --rows n		разместить страницы в n рядов
    -B			не выводить заголовки
    -b text		текст заголовка страницы
    -f n		использовать шрифт размера n
    -l			число символов в строке
    -L			число строк на странице
    -M			формат бумаги (A4)
    -n			число копий
    -o			вывести в файл, если - то стандартный вывод
    -P			имя принтера для вывода
    -R			в книжной ориентации
    -r			в альбомной ориентации
    -T n		установить табулостопы через n символов
    -u text		текст для нижнего слоя (водянка)
enscript		похож на a2ps, но принимает только текстовые данные

lpr			печать файлов
    -P			указать принтер
    -# n		n копий
    -p			выводить на каждой странице дату, время, имя задания и номер страницы
    -r			удалить файлы после печати
lp			тоже печать
    -d			выбрать принтер
    -n число		число копий
    -0 landscape	альбомная ориентация
    -o fitplot		масштабировать файл, чтобы уместить на странице
    -o scaling=n	масштабировать файл с указанным коэффициентом (от 100%)
    -o cpi		плотность символов на дюйм
    -o lpi		плотность строк на дюйм
    -o page-bottom
    -o page-top
    -o page-left
    -o page-right	размеры полей в пунктах
    -P страницы		список страниц для печати
lsusb			определить принтер и его ид
cups			common unix print system
systemctl enable cups	включить купс
systemctl start cups	запустить
localhost:631		веб морда админки, тут надо установить свой принтер по умолчанию
lpstat -a		список принтеров, известных системе
lpstat -s		подробное описание конфигурации печати
    -a printer		состояние очереди печати для указанного принтера
    -d			имя принтера по умолчанию
    -p printer		состояние указанного принтера
    -r			состояние сервера печати
    -s			сводная информация о состоянии
    -t			полный отчет о состоянии
lpq			информация об очереди печати для принтера по умолчанию
    -P printer		для конкретного принтера
cancel n		отменить задание печати номер n (номер из lpq)
lprm			аналогично

make			для сборки программ из исходников
gcc			gnu c compiler, компилятор
configure		обычно сценарий командной оболочки для анализа окружения сборки
			и проверки наличия необходимых инструментов и компонентов
			создает makefile, без которого make работать не будет
make install		позволяет установить собранную программу в системный каталог (если предусмотрено)

#!			shebang (?)
$?			результат последней команды (0 - все гуд, !0 - не все гуд)
$$			пид текущего процесса (оболочки, например)
true			всегда возвращает 0
false			всегда возвращает 1
test или [ expr ]	проверки и сравнения

pwd -P			реальный путь для каталога-симлинка, если мы в нем

переменные окружение передаются запускаемым командам
переменные оболочки используются только оболочкой
изначально командой ИМЯ=ЗНАЧЕНИЕ устанавливается переменная оболочки
командой export ИМЯ можно сделать переменную оболочки переменной окружения

/usr/share/doc		здесь иногда можно найти документацию, не включенную в man/info

dmesg			посмотреть последние сообщения ядра
lsscsi			посмотреть информацию о scsi дисках
chvt n			сменить консоль на консоль номер n
lsof			список открытых файлов (list open files)
strace			отследить системные вызовы
ltrace			отследить вызовы библиотек
iostat			подобно vmstat, только для устройств ввода-вывода
iotop			использование ввода-вывода каждым процессором
pidstat			отслеживание процессов

разрешение сетевых имен:
/etc/hosts
/etc/resolv.conf