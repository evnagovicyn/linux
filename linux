выделить левой кнопкой - затем щелкнуть средней - копировать/вставить фрагмент текста
фокус передается по щелчку - не по движению мыши

CTRL+SHIFT+C		copy
CTRL+SHIFT+V		paste

приглашение к вводу (shell prompt) - [username@computername workingdir]
~			домашний каталог пользователя
если последний символ в приглашении - #, то сеанс в оболочке имеет права рута (суперпользователя)

стрелки вверх/вниз	листать историю команд
стрелки влево/вправо	управлять позицией курсора

date 			текущая дата и время
cal 			календарь
df 			disk free, объем свободного пространства на дисках
 -h			human readable
 -T			тип
 -i			айноды
du			disk usage, сколько занято места
 -h			human readable
 -s			суммарный объем для каждого аргумента
free 			объем свободной оперативной памяти
uname			версия ядра

ctrl-alt-f*		переключение между терминалами

pwd 			print working directory - текущий каталог
cd 			change directory - смена каталога
ls 			список каталогов и файлов
realpath		реальный и наиболее правильный путь к файлу
ll			 ls -la

максимальная длина имени файла - 255 символов
/ - корневой каталог, все остальные каталоги находятся в нем.
по сути файловая система - перевернутое дерево с корнем вверху, от которого расходятся различные каталоги
абсолютный путь - путь, начинающийся с корня, например /home/nag
относительный путь - путь относительно текущей директории, например в директории /home/nag путь Downloads - относительный
.	текущий каталог
..	родительский каталог
файлы и каталоги, начинающиеся с . считаются скрытыми, и ls выведет их только с ключом -a
расширения файлов не имеют значения для ОС, но могут иметь значение для софта
кроме букв и цифр, в названии каталогов и файлов следует использовать только тире и подчеркивание

cd - 			предыдущий рабочий каталог
cd ~ 			домашний каталог текущего пользователя
cd ~username 		домашний каталог пользователя username

ls можно использовать с названием директории или файла (и нескольких) - выведет содержимое директории или информацию о файле
несколько параметров можно комбинировать в одну строку
ls:
 -a			выводить все файлы и каталоги
 -А			выводить все файлы, кроме . и ..
 -l			подробный вывод
 -t			сортировать по времени последнего изменения
 -S			сортировать по размеру
 -r			в обратном порядке
 -d			инфо о самом каталоге, а не его содержимом
 -h			отображает размер в понятных единицах измерения
 -i			вывести айноды
вывод ls:
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Desktop
1 столбец 		тип файла и права (юзер, группа, остальные)
2 			количество хардлинков
3 			владелец
4 			группа владелец
5 			размер (1 блок 4096 байт в ext4)
6 			дата и время последнего изменения
7 			имя файла

stat			информация из айнод
file 			тип файла
reset			сброс оболочки
clear			очистка окна терминала
history			содержимое истории команд

less			просмотр текстовых файлов (пейджер)
 PgUp/b			на одну страницу назад
 PgDn/Space		на одну страницу вперед
 Up/Down		на одну страницу назад/вперед
 G/g			в конец/начало файла
 /string		искать ниже по тексту строку
 n/N			следующая/предыдущая строка по поиску
 h			справка
 q			выйти

интересные каталоги:
/boot			ядро, загрузчик
/dev			устройства
/etc			конфиги
/home			домашние папки юзеров
/lib			библиотеки
/lost+found		частично восстановленные файлы
/media			каталог для монтирования флэшэк, дисков
/mnt			то же самое
/proc			вфс, процессы в системе
/root			папка рута
/sys			информация об устройствах, драйверах, ядре
/tmp			временные файлы
/var/log		логи

символические ссылки (симлинки):
занимают новую айноду, по сути новый блок данных, который просто ведет на другой уже существующий.
если удалить саму ссылку, то файл останется на месте, если удалить файл - образуется битая ссылка.
по сути это ярлыки из винды.
жесткие ссылки (хардлинки):
занимают ту же айноду, что и цель, по сути новое имя для того же блока данных.
неотличимы от файлов. Пока есть хотя бы 1 хл, файл существует.
Как только последний хл удален - файл удален.
хардлинки можно создавать только в рамках одной ФС
нельзя создавать хардлинки на директории
ln -s цель название	создать симлинк
ln цель название	создать хардлинк
!цель должна иметь путь относительно директории, в которой будет сама ссылка, либо абсолютный путь!

cp			копирование, если без -r, то целевой каталог должен существовать
cp -a			скопировать со всеми атрибутами (права, владельцы) - по умолчанию берутся атрибуты по умолчанию для юзера, выполняющего копирование
cp -u			скопировать только новые файлы (раннее не существующие или с более поздней датой изменения)
cp -r			рекурсивное копирование (копирование файлов). Если каталог существует - скопирует сам каталог и содержимое,
			если не существует - создаст и заполнит содержимым
cp -i			спрашивать подтверждение перед перезаписью (по умолчанию перезаписывает без подтверждения)
cp -v			выводить подробные сообщения
mv			перемещение/переименование (если целевой каталог не существует - создаст его и в нем уже сразу будут внутренности исходного каталога, 
			если существует - переместит в него)/ если при перемещении файлов целевой файл уже существует - перезапишет его без подтверждения
mv -u			тот же смысл, что с cp
mv -v			то же, что с cp
mv -i			то же, что с cp
rm			удаление
rm -r			рекурсивное удаление (удаление каталогов)
rm -i			то же, что и для cp и mv
rm -f			игнорировать отсутствующие файлы и не запрашивать подтверждения
rm -v			то же, что и для cp и mv
rmdir			удаление каталогов (пустых)
mkdir			создание каталога
 -p			создание каталога с подкаталогами
touch			создание пустого файла или обновление времени изменения существующего

wildcards:
*			любое количество любых символов
?			один любой символ
[abc]			любой один символ из abc
[!abc]			любой один символ не из !abc
[[:класс:]]		любой один символ из указанного класса
[a-d]			любой символ из диапазона символов

!перед тем, как проводить операции с файлами с использованием подстановок,
лучше проверить, какие файлы попадут под операцию, используя ls с теми же подстановками!

классы:
[:alnum:]		любой алфавитно-цифровой символ
[:alpha:]		любой алфавитный символ
[:digit:]		любой цифровой символ
[:lower:]		любая буква в нижнем регистре
[:upper:]		любая буква в верхнем регистре

xdg-open		открыть файл в назначенной для данного типа файлов программе
ssh-keygen -t rsa -b 4096 -C "email"	генерация ссш-ключей
xclip -sel clip -i file	скопировать файл в буфер
xclip -sel clip -o	вставить из буфера

type			тип команды (встроенная, бинарник, альяс)
whereis			путь к бинарнику и ману
which			местоположение исполняемого файла
who			кто работает в системе
help			справка по команде
--help			ещё одна справка
man			страницы руководства по команде

разделы man:
1			пользовательские программы
2			интерфейсы системных вызовов в ядре
3			интерфейсы в библиотеке си
4			специальные файлы(устройства, драйвера)
5			форматы файлов
6			игры и развлечения
7			прочее
8			команды системного администрирования
использование разделов:
man раздел искомая_информация

apropos			найти страницы руководство для близких совпадений с искомым термином
man -k			то же, что и apropos
man bash		самая экстремальная "страница" руководства

whatis			имя и краткое описание программы
info			ещё одна справка
 ?			вывести справка
 PgUp/Backspace		предыдущая страница
 PgDn/Space		следующая страница
 n			следующий раздел
 p			предыдущий раздел
 u			вывести родительский раздел по отношению к текущему
 enter			перейти по ссылке, находящейся под курсором
 q			выход

zless			выводит содержимое файлов, сжатых архиватором gzip

команды можно разделить ; и поместить в одну строку
alias name='command[s]'	создать альяс
unalias			удалить альяс
alias без аргументов	список альясов

3 стандартных потока:
дескриптор 0		стандартный ввод
дескриптор 1		стандартный вывод
дескриптор 2		стандартная ошибка

перенаправление вывода:
>			перенаправить вывод. Если в файл, то если файл существует, он будет перезаписан (всегда), если не существует - создан
>>			тоже, но если файл существует, вывод будет дописан, то есть для очистки файла можно просто написать
			> file	очистит файл
2>			перенаправление дескриптора 2 (поток ошибок)
2>&1			перенаправление потока ошибок туда же, куда и дескриптор 1 (поток вывода)
аргументы перенаправления читаются слева направо, так что порядок перенаправления важен:
..>file 2>&1		перенаправит поток ошибок в file
  2>&1 >file		перенаправит поток ошибок на экран, а поток вывода в файл
в современных bash:
&>			перенаправление сразу и вывода и ошибок

/dev/null		спец файл, битоприемник, который ничего не делает с вводом. Перенаправление сюда отбросит выбранный поток

<			перенаправление дескриптора 0 (потока ввода). Позволяет использовать файлы в качестве источника данных для команды
|			отправить вывод одной команды на ввод другой - создать конвеер (pipeline, pipe)

cat			чтение одного или нескольких файлов в стандартный вывод
без аргументов		чтение стандартного ввода с консоли. Ctrl+D, чтобы закончить.

cat > file		создать файл и заполнить его потоком из стандартного ввода

sort			сортировка ввода
uniq			поиск и удаление повторяющихся строк из ввода
 -d			не удаляет, а наоборот оставляет только дублирующиеся строки
wc			вывод числа байт, слов и строк
 -l			только число строк
grep			супер мощная фильтрация по регуляркам
 -i			игнорировать регистр
 -R			рекурсивный поиск
 -l			имена файлов
 -v			только строки, где совпадение НЕ найдено
    [ ]			диапазон
    ^			отрицание
    +			1 и более раз
    |			или
    \s			пробельные символы
    *			0 и более раз
    ?			может быть а может и не быть
    { }			количество символов
head			вывести первые 10 строк
 -n 5			не 10, а 5 строк
tail			вывести последние 10 строк
 -n 5			не 10, а 5
 -f			мониторинг за изменением файла (супер вещь)
tee			выводить информацию со стандартного ввода в файл И в стандартный вывод
echo			выводит стандартный ввод на стандартный вывод

.[!.]?*			шаблон для вывода файлов с точкой, но без директорий . и ..
~			домашний каталог текущего пользователя
~user			домашний каталог пользователя user
$((выражение))		можно считать арифметические выражения
 +			сложение
 -			вычитание
 *			умножение
 /			деление
 %			остаток от деления
 **			возведение в степень
{1,2,3}			вывести множество строк с каждым из аргументов
{001..15}		то же самое, с использованием диапазона
echo $VAR		вывести переменную VAR
$USER			имя пользователя
$PATH			командный путь


printenv		список доступных переменных
$(cmd)/'cmd'		подстановка вывода команд в качестве аргументов других команд (не тоже самое, что перенаправление)
например ls -l $(which cp) выведет информацию о файле /bin/cp
""			двойные кавычки позволяют экранировать некоторые специальные символы, и интерпретировать их как обычные
при этом подстановка параметров, арифметики и команд все ещё работают в двойных кавычках.
''			одинарные кавычки позволяют экранировать вообще все специальные символы
\			экранировать 1 символ или ввести управляющий символ
 \a			звонок
 \b			backspace
 \n			новая строка
 \r			возврат каретки
 \t			табуляция
\\			экранировать обратный слэш
echo -e			позволяет интерпретировать управляющие символы
$''			тоже самое

CTRL+A			в начало строки
CTRL+E			в конец строки
CTRL+F			на один символ вперед (стрелка вправо)
CTRL+B			на один символ назад (стрелка влево)
ALT+F/CTRL+вправо	на одно слово вперед
ALT+B/CTRL+влево	на одно слово назад
CTRL+L			очищает экран (clear)
CTRL+D			удаление символа под курсором
CTRL+T			поменять местами 2 символа - под курсором и предыдущий
ALT+T			поменять местами 2 слова - под курсором и предыдущий
ALT+L			перевести в нижний регистр символы, начиная с позиции под курсором и до конца слова
ALT+U			перевести в верхний регистр символы, начиная с позиции под курсором и до конца слова
CTRL+K			удалить символы от позиции курсора до конца строки
CTRL+U			удалить символы от позиции курсора до начала строки
ALT+D			удалить символы от позиции курсора до конца слова
ALT+BACKSPACE		удалить символы от позиции курсора до начала слова
CTRl+Y			извлекает текст из буфера удалений и вставляет его в позицию курсора
TAB			дополнение, работает с:
    именами переменных в $
    именами пользователей в ~
    командами
    файлами
    сетевыми именами

!число			подстановка записи из истории под данным номером строки
CTRL+R			поиск по истории
ENTER			выполнить найденную в истории команду
CTRL+J			закончить поиск по истории и скопировать найденную команду
CTRL+G/C		закончить поиск по истории

script [file]		сохранение в файл сеанса работы с командной строкой, либо в файл typescript по умолчанию

id			выводит информацию о юзере
chmod			изменение прав
umask			разрешения доступа к файлам по умолчанию
su			запуск оболочки от имени другого пользователя
sudo			запуск команды от имени другого пользователя
chown			смена владельца файла
chgrp			смена группы файла
passwd			смена пароля пользователя
addgroup		добавление группы
useradd			добавление пользователя
 -g			в конкретную группу

CTRL+D			выйти из сеанса (команда exit)

/etc/passwd		учетные записи
/etc/group		группы
/etc/shadow		хэши паролей

максимальная длина имени юзера - 32 символа, нельзя использовать : и new line
root uid = 0

uid			user id
gid			group id

типы файлов:
 -			обычный файл
 d			каталог
 l			симлинк
 c			символьное устройство (обрабатывают данные как потоки байтов)
 b			блочное устройство (обрабатывают данные блоками - диски)

права:
группа из 3 бит для каждой категории
u - user
g - group
o - other
---------
a - all, все
r - открытие и чтение файла. чтение содержимого каталога (ограниченно, если нет прав x)
w - запись в файл или удаление информации из него, но не переименование или удаление самого файла. переименование или перемещние каталога, создание, удаление и переименование файлов внутри каталога (если стоит x)
x - запуск бинарников/интерпретация скриптов. вход в каталог

изменить права может только владелец или рут.
chmod удобно использовать с восьмеричными цифрами, т.к. каждая группа содержит по 3 бита, определяющих права доступа.
0	000	---
1	001	--x
2	010	-w-
3	011	-wx
4	100	r--
5	101	r-x
6	110	rw-
7	111	rwx
chmod 777	7 для user, 7 для group, 7 для other
chmod (u/g/o/a)(+/-/=)(r/w/x) - смена прав в символьном режиме, через запятую можно указывать разные режимы для разных групп

umask	выводит или задает маску, которая применяется к файлам по мере их создания

скрытые биты:
setuid	при применении к исполняемому файлу, при его запуске он запускается от имени владельца, а не запускающего юзера
setgid	то же, только для группы. для каталога - создаваемые файлы будут группе-владельцу, а не группе юзера, создавшего файл
sticky	для каталогов не позволяет удалять или переименовывать файлы

su username		запуск нового сеанса оболочки от имени username
 -l			запущенная оболочка станет оболочкой входа, т.е. будет загружено окружение пользователя и текущим каталогом станет его домашний каталог
 -c			выполнить команду
если пользователь не указан, подразумевается root
-l можно сократить до -
su -			запустить оболочку от имени рута

sudo			запустить команду от имени рута, используя свой пароль
 -l			список привилегий
 -i			интерактивный режим

sudo su			работать под рутом

chown user:group file	изменить владельца и группу-владельца файла
можно менять отдельно владельца и отдельно группу:
chown user		назначить владельца
chown :group		назначить группу-владельца
chown user:		назначить владельца и его группу

chgrp			тоже позволяет сменить группу-владельца
usermod			модификация пользователя

pid			process id
ppid			parent process id

ps			список процессов для текущего терминала
 x			для всех терминалов
 -A/-e			для всех пользователей
 -u			user-oriented format
 -f/F			подробный/очень подробный формат
 -l			ещё один подробный формат

состояния (stat):
 R			выполняется
 S			приостановлен
 D			приостановлен без возможности прерывания
 T			остановлен
 Z			зомби (процесс, который завершился, но результат работы не был обработан родителем)
 <			высокоприоритетный процесс
 N			низкоприоритетный процесс

daemon			программа, работающая в фоне без прямого взаимодействия
зомби			состояние процесса между своим exit() и wait() родителя
сирота			процесс без родителя
чтобы убить зомби, надо сделать его сиротой, тогда его усыновит initd, считает код возврата и завершит
& в конце команды - запустить в фоне, выводит номер задания и пид
CTRL+C			завершить команду
CTRL+Z			приостановить команду

top			мониторинг процессов в реальном времени
1 строка:
    имя программы
    текущее время
    аптайм
    количество юзеров
    среднее число ожидающих ресурсов процессов за 60 секунд, 5 минут и 15 минут, дб <= кол-во ядер
	в linux в эту очередь попадают процессы, ожидающие ввода-вывода
2 строка:
    сколько процессов и их статус
3 строка:
    us	потрачено п.времени в пространства пользователя
    sy	в пространстве ядра
    ni	потрачено п.времени на процессы с пониженным приоритетом
    id	простой
    wa	потрачено на ожидание ввода-вывода
    hi	потрачено на аппаратные прерывания
    si	потрачено на системные вызовы
    st	загрузка хостовой машины для виртуалок
4 строка использование озу
5 строка использование файла подкачки
S			поменять время обновления
1			показать по ядрам

jobs			показать список заданий
fg			вернуть задание в передний фон
fg %1			вернуть задание № 1
bg			перевести в фоновый режим приостановленную команду
kill			завершить процесс
 -l			список сигналов
сигналы:
1	HUP		обрыв связи, пережиток прошлого
2	INT		прервать (CTRL+C)
3	QUIT		выйти?
9	KILL		безусловное завершение (необрабатываемый сигнал. Только init может его обработать)
11	SEGV		ошибка сегментации - посылается программе, которая пытается допустить неправильный доступ к памяти
15	TERM		завершение, сигнал по умолчанию. Можно обработать и прибрать за собой
18	CONT		продолжить, восстановление после STOP
19	STOP		приостановить. Как и KILL не обрабатывается, просто приостанавливает
20	TSTP		приостановить (CTRL+Z), обрабатываемый сигнал
28	WINCH		изменение размера окна (влияет, например, на less и top)
kill сигнал пид		передать указанный сигнал указанному процессу

killall			позволяет послать сигнал программам, соответствующим определенному пользователю или имени программы

halt			приостановить функции CPU, но оставить включенным
poweroff		выключить питание
reboot			перезагрузка
shutdown		выключение системы
 now			сейчас

pstree			дерево процессов
vmstat			снимок об использовании системных ресурсов
tload			график загрузки системы в реальном времени


set			выводит список и переменных окружения и переменных оболочки

файлы запуска для сеансов командной оболочки:
/etc/profile		общесистемный конфиг для всех пользователей
~/.bash_profile		пользовательский файл запуска для переопределения системных настроек
~/.bash_login		вместо bash_profile
~/.profile		вместо bash_profile и bash_login

файлы запуска для сеансов оболочки из графического окружения:
/etc/bash.bashrc	общесистемный конфиг
~/.bashrc		пользовательский конфиг для переопределения или добавления настроек

export $VAR		сделать доступной переменную окружения для дочерних процессов (т.е. для fork())
экспортировать переменные следует в .bashrc

nano
    CTRL+X		выйти
    CTRL+O		сохранить

source конфигc		заставить шелл повторно прочитать конфиг

vim
    :q!			выйти
    i			режим вставки (курсор остается на месте вставки)
    :w			запись изменений
    :wq!		сохранить и выйти
    l/вправо		вправо на 1 символ
    h/влево		влево на 1 символ
    j/вниз		вниз на 1 строку
    J			объединить текущую строку со следующей
    k/вверх		вверх на 1 строку
    0			в начало строки
    ^			к первому непробельному символу в строке
    $			в конец строки
    w			в начало следующего слова или к знаку препинания
    W			в начало следующего слова минуя знаки препинания
    b			в начало предыдущего слова или к знаку препинания
    B			в начало предыдущего слова минуя знаки препинания
    CTRL+F/PgDn		вниз на одну страницу
    CTRL+B/PgUp		вверх на одну страницу
    nG			к строке n
    G			к последней строке
    u			отмена последнего действия
    a			режим добавления (курсор уходит за выделенный символ)
    A			перейти в конец строки и включить режим добавления
    o			вставить строку ниже текущей
    O			вставить строку выше текущей
    x			удалить символ в позиции курсора
    3х			текущий символ и следующие 2
    dd			удалить текущую строку
    5dd			текущую строку и следующие 4
    dW			от символа в позиции до начала следующего слова
    d$			до конца строки
    d0			до начала строки
    d^			до первого непробельного символа
    dG			до конца файла от текущей строки
    d20G		от текущей строки до 20 строки файла
    p			вставка справа от курсора
    P			вставка слева от курсора
    yy			скопировать текущую строку
    5yy			скопировать текущую строку и следующие 4
    yW			от курсора до начала слова
    y$			до конца строки
    y0			до начала строки
    y^			до первого непробельного символа
    yG			до конца файла от текущей строки
    y20G		от текущей строки до 20 строки файла
    f			поиск в строке, ; - повторить поиск
    /			поиск по файлу, n - следующий результат, N - предыдущий. Можно регулярками
    :%s/что/на что/g	замена первого на второго, с поиском по всему файлу (%) и глобальной заменой (g)
	c		запрашивать подтвеждение на замену
	    y		заменить
	    n		пропустить
	    a		заменить это и все последующие
	    q		завершить
	    l		заменить и завершить
	    CTRL+E/CTRL+Y	прокрутить вверх/вниз
    :bn			следующий файл
    :bp			предыдущий файл
    :buffers		список редактируемых файлов
    :buffer n		перейти к файлу n
    :e file		открыть доп файл для редактирования
    :r file		вставить файл перед курсором
    ZZ			в командном режиме сохранить и выйти

PS1			строка приглашения


.deb			пакеты в Debian based
.rpm			пакеты в Red Hat based

dpkg			низкоуровневый инструмент
apt*			высокоуровневый инструмент

apt-get update		обновить кэш
apt-cache search	поиск пакета
apt-get install		установка пакета из репо
dpkg -i			установка/обновление пакета из файла(возможно нужно будет разрешить зависимости)
apt-get remove		удаление пакета
apt-get upgrade		обновление установленных пакетов
dpkg -l			список установленных пакетов
dpkg -s			установлен ли определенный пакет
apt-cache show		получить описание пакета
dpkg -S			в составе какого пакета был установлен тот или иной файл


/etc/fstab		устройства (обычно разделы дисков), монтируемые на этапе загрузки